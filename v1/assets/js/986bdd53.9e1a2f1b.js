"use strict";(self.webpackChunk_ui5_webcomponents_website=self.webpackChunk_ui5_webcomponents_website||[]).push([[1920],{2963:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var s=t(1085),i=t(1184);const r={},o="TypeScript Development",a={id:"docs/development/typescript-in-UI5-Web-Components",title:"TypeScript Development",description:"Since 1.11.0 we migrated the framework and all components to TypeScript.",source:"@site/docs/docs/5-development/07-typescript-in-UI5-Web-Components.md",sourceDirName:"docs/5-development",slug:"/docs/development/typescript-in-UI5-Web-Components",permalink:"/webcomponents/v1/docs/development/typescript-in-UI5-Web-Components",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"documentationSidebar",previous:{title:"Deep dive and best practices",permalink:"/webcomponents/v1/docs/development/deep-dive-and-best-practices"},next:{title:"Contributing to the UI5 Web Components Project",permalink:"/webcomponents/v1/docs/contributing/"}},l={},c=[{value:"Component Metadata",id:"component-metadata",level:2},{value:"Decorators",id:"decorators",level:3},{value:"Class decorators",id:"class-decorators",level:3},{value:"Property decorators",id:"property-decorators",level:3},{value:"Defining properties (<code>@property</code>)",id:"defining-properties-property",level:3},{value:"Usage of <code>@name</code> in properties&#39; documentation",id:"usage-of-name-in-properties-documentation",level:3},{value:"Usage of <code>?</code> and <code>!</code>",id:"usage-of--and-",level:3},{value:"Never initialize metadata properties. Use <code>defaultValue</code> instead.",id:"never-initialize-metadata-properties-use-defaultvalue-instead",level:3},{value:"Defining slots (<code>@slot</code>)",id:"defining-slots-slot",level:3},{value:"Default slot with <code>propertyName</code>",id:"default-slot-with-propertyname",level:4},{value:"Named slot",id:"named-slot",level:4},{value:"Default slot without <code>propertyName</code>",id:"default-slot-without-propertyname",level:4},{value:"What about <code>managedSlots</code>?",id:"what-about-managedslots",level:4},{value:"Defining events",id:"defining-events",level:3},{value:"Events",id:"events",level:2},{value:"Conventions and guidelines",id:"conventions-and-guidelines",level:2},{value:"Conventions",id:"conventions",level:3},{value:"TypeScript-specific guidelines",id:"typescript-specific-guidelines",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"typescript-development",children:"TypeScript Development"}),"\n",(0,s.jsx)(n.p,{children:"Since 1.11.0 we migrated the framework and all components to TypeScript.\nIn addition to the pure code migration, we introduced a new format of component metadata definition leveraging TypeScript decorators."}),"\n",(0,s.jsx)(n.h2,{id:"component-metadata",children:"Component Metadata"}),"\n",(0,s.jsx)(n.h3,{id:"decorators",children:"Decorators"}),"\n",(0,s.jsx)(n.p,{children:"We use decorators to describe the components' metadata. Here is the list of all available decorators:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import customElement from "@ui5/webcomponents-base/dist/decorators/customElement.js";\nimport property from "@ui5/webcomponents-base/dist/decorators/property.js";\nimport slot from "@ui5/webcomponents-base/dist/decorators/slot.js";\nimport event from "@ui5/webcomponents-base/dist/decorators/event.js";\n'})}),"\n",(0,s.jsx)(n.h3,{id:"class-decorators",children:"Class decorators"}),"\n",(0,s.jsx)(n.p,{children:"The class decorators are used just before the component's class declaration and applied to the constructor of the class to describe the component:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@customElement"})," - to define class-related metadata entities: ",(0,s.jsx)(n.code,{children:"tag"}),", ",(0,s.jsx)(n.code,{children:"renderer"}),", ",(0,s.jsx)(n.code,{children:"template"}),", ",(0,s.jsx)(n.code,{children:"styles"}),", ",(0,s.jsx)(n.code,{children:"dependencies"})," and more."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import customElement from "@ui5/webcomponents-base/dist/decorators/customElement.js";\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@event"})," - to define the events, fired by the component"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import event from "@ui5/webcomponents-base/dist/decorators/event.js";\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@customElement("ui5-menu")\n@event("item-click", {\n\tdetail: {\n\t\titem: {\n\t\t\ttype: Object,\n\t\t},\n\t\ttext: {\n\t\t\ttype: String,\n\t\t},\n\t},\n})\nclass MyClass extends UI5Element {\n\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example:"})," ",(0,s.jsx)(n.code,{children:"@customElement"})," can be used to define all class-related metadata entities:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@customElement({\n\ttag: "my-element-name",\n\tlanguageAware: true,\n\tthemeAware: true,\n\tfastNavigation: true,\n\trenderer: Renderer,\n\tstyles: MyElementStyles,\n\ttemplate: MyElementTemplate,\n\tstaticAreaStyles: MyStaticAreaStyles,\n \tstaticAreaTemplate: MyStaticAreaTemplate,\n\tdependencies: [ComponentA, ComponentB],\n})\nclass MyElement extends UI5Element {\n\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": the ",(0,s.jsx)(n.code,{children:"static get render()"})," that we use when developing in JavaScript (still supported for backward compatibility) is replaced with ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"renderer"})})," in the ",(0,s.jsx)(n.code,{children:"@customElement"})," decorator."]}),"\n",(0,s.jsx)(n.h3,{id:"property-decorators",children:"Property decorators"}),"\n",(0,s.jsx)(n.p,{children:"These are used inside the class and are associated with accessors (class members).\nThese decorators are used for properties and slots:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@property"}),"- to define components' properties"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import property from "@ui5/webcomponents-base/dist/decorators/property.js";\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@slot"})," - to define components' slots"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import slot from "@ui5/webcomponents-base/dist/decorators/slot.js";\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"defining-properties-property",children:["Defining properties (",(0,s.jsx)(n.code,{children:"@property"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"@property"})," decorator has a single parameter of type object with the following fields to describe a component property:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"type?: BooleanConstructor | StringConstructor | ObjectConstructor | DataType"}),"\n",(0,s.jsx)(n.li,{children:"validator?: DataType,"}),"\n",(0,s.jsx)(n.li,{children:"defaultValue?: PropertyValue,"}),"\n",(0,s.jsx)(n.li,{children:"noAttribute?: boolean,"}),"\n",(0,s.jsx)(n.li,{children:"multiple?: boolean,"}),"\n",(0,s.jsx)(n.li,{children:"compareValues?: boolean,"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The fields are explained in detail in the ",(0,s.jsx)(n.a,{href:"/webcomponents/v1/docs/development/deep-dive-and-best-practices",children:"Deep dive and best practices"})," article."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example:"}),' "',(0,s.jsx)(n.code,{children:"String"}),' properties with no specific default value" - we skip all settings as ',(0,s.jsx)(n.code,{children:"String"})," is the default type and ",(0,s.jsx)(n.code,{children:"empty string"})," is the default value."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'/**\n * Defines the header text of the menu (displayed on mobile).\n *\n * @name sap.ui.webc.main.Menu.prototype.headerText\n * @type {string}\n * @defaultvalue ""\n * @public\n */\n@property()\nheaderText!: string;\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example:"}),' "Properties with enumerated values" - we use ',(0,s.jsx)(n.code,{children:"enum"})," for both the TypeScript class member and the property metadata in the decorator"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'/**\n * Defines the component design.\n *\n * @type {sap.ui.webc.main.types.ButtonDesign}\n * @name sap.ui.webc.main.Button.prototype.design\n * @defaultvalue "Default"\n * @public\n */\n@property({ type: ButtonDesign, defaultValue: ButtonDesign.Default })\ndesign!: ButtonDesign;\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example:"})," use ",(0,s.jsx)(n.code,{children:"validator"})," instead of ",(0,s.jsx)(n.code,{children:"type"})," for ",(0,s.jsx)(n.code,{children:"DataType"})," descendants (although ",(0,s.jsx)(n.code,{children:"type"})," still works for compatibility)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n * Defines component's timestamp.\n * <b>Note:</b> set by the Calendar component\n * @type {sap.ui.webc.base.types.Integer}\n * @name sap.ui.webc.main.CalendarHeader.prototype.timestamp\n * @public\n */\n@property({ validator: Integer })\ntimestamp?: number;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"validator"})," setting is preferable to ",(0,s.jsx)(n.code,{children:"type"})," as it avoids confusion with the actual TypeScript type (i.e. ",(0,s.jsx)(n.code,{children:"number"})," in this example)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example:"})," TypeScript types (",(0,s.jsx)(n.code,{children:"string"}),", ",(0,s.jsx)(n.code,{children:"boolean"}),") are used for TypeScript class members, and  Javascript constructors (",(0,s.jsx)(n.code,{children:"String"}),", ",(0,s.jsx)(n.code,{children:"Boolean"}),") for the metadata settings (as before)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"@property({ type: Boolean })\nhidden!: boolean;\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"usage-of-name-in-properties-documentation",children:["Usage of ",(0,s.jsx)(n.code,{children:"@name"})," in properties' documentation"]}),"\n",(0,s.jsxs)(n.p,{children:["Set the ",(0,s.jsx)(n.code,{children:"@name"})," JSDoc annotation for all ",(0,s.jsx)(n.em,{children:"public"})," properties as JSDoc cannot associate the JSDoc comment with the property in the code.\nThis will not be necessary once we've switched to TypeDoc."]}),"\n",(0,s.jsxs)(n.h3,{id:"usage-of--and-",children:["Usage of ",(0,s.jsx)(n.code,{children:"?"})," and ",(0,s.jsx)(n.code,{children:"!"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"?"})," for all metadata properties that may be ",(0,s.jsx)(n.code,{children:"undefined"})," or ",(0,s.jsx)(n.code,{children:"null"}),", and ",(0,s.jsx)(n.code,{children:"!"})," for all other metadata properties. As a rule of thumb:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Boolean"})," properties are always defined with ",(0,s.jsx)(n.code,{children:"!"})," as they\nare always ",(0,s.jsx)(n.code,{children:"false"})," by default"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"@property({ type: Boolean })\ninteractive!: boolean;\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"String"})," properties are always defined with ",(0,s.jsx)(n.code,{children:"!"})," as they\nare ",(0,s.jsx)(n.code,{children:"empty string"})," by default, unless you specifically set ",(0,s.jsx)(n.code,{children:"defaultValue: undefined"})," (then use ",(0,s.jsx)(n.code,{children:"?"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"@property()\ntext!: string;\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"@property({ defaultValue: undefined })\ntarget?: string;\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["properties with ",(0,s.jsx)(n.code,{children:"validator"})," set, should be always defined with ",(0,s.jsx)(n.code,{children:"?"})," as they are ",(0,s.jsx)(n.code,{children:"undefined"})," by default, unless you specify a ",(0,s.jsx)(n.code,{children:"truthy"})," default value."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"@property({ validator: Float })\nwidth?: number\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"never-initialize-metadata-properties-use-defaultvalue-instead",children:["Never initialize metadata properties. Use ",(0,s.jsx)(n.code,{children:"defaultValue"})," instead."]}),"\n",(0,s.jsx)(n.p,{children:"Wrong:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class Button extends UI5Element {\n\t@property({ type: ButtonDesign })\n\tdesign: ButtonDesign = ButtonDesign.Default;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Also Wrong:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class Button extends UI5Element {\n\t@property({ type: ButtonDesign })\n\tdesign: ButtonDesign;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.design = ButtonDesign.Default;\n\t}\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Correct:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class Button extends UI5Element {\n\t@property({type: ButtonDesign, defaultValue: ButtonDesign.Default })\n\tdesign!: ButtonDesign;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," we use ",(0,s.jsx)(n.code,{children:"!"})," to instruct the TypeScript compiler that the variable will be initialized with a default value different than ",(0,s.jsx)(n.code,{children:"null"})," and ",(0,s.jsx)(n.code,{children:"undefined"}),", since the TypeScript compiler does not know about the component lifecycle and the fact that the framework will initialize the ",(0,s.jsx)(n.code,{children:"design"})," class member."]}),"\n",(0,s.jsxs)(n.h3,{id:"defining-slots-slot",children:["Defining slots (",(0,s.jsx)(n.code,{children:"@slot"}),")"]}),"\n",(0,s.jsx)(n.p,{children:"There are 3 common patterns for defining slots:"}),"\n",(0,s.jsxs)(n.h4,{id:"default-slot-with-propertyname",children:["Default slot with ",(0,s.jsx)(n.code,{children:"propertyName"})]}),"\n",(0,s.jsx)(n.p,{children:"Before:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'/**\n * @type {HTMLElement[]}\n */\n"default": {\n\ttype: HTMLElement,\n\tpropertyName: "items",\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"After:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'/**\n * @name sap.ui.webc.main.SomeComponent.prototype.default\n * @type {HTMLElement[]}\n */\n@slot({ "default": true, type: HTMLElement })\nitems!: Array<SomeItem>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Use the ",(0,s.jsx)(n.code,{children:"propertyName"})," as the class member, set ",(0,s.jsx)(n.code,{children:'"default": true'})," in the\ndecorator definition, and use ",(0,s.jsx)(n.code,{children:"prototype.default"})," as the JSDoc ",(0,s.jsx)(n.code,{children:"@name"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"named-slot",children:"Named slot"}),"\n",(0,s.jsx)(n.p,{children:"Before:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * @type {HTMLElement[]}\n */\ncontent: {\n\ttype: HTMLElement,\n\tinvalidateOnChildChange: true,\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"After:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n * @name sap.ui.webc.main.SomeComponent.prototype.content\n * @type {HTMLElement[]}\n */\n@slot({ type: HTMLElement, invalidateOnChildChange: true })\ncontent!: Array<HTMLElement>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Use the slot name as the class member, and again in the JSDoc ",(0,s.jsx)(n.code,{children:"@name"}),"."]}),"\n",(0,s.jsxs)(n.h4,{id:"default-slot-without-propertyname",children:["Default slot without ",(0,s.jsx)(n.code,{children:"propertyName"})]}),"\n",(0,s.jsx)(n.p,{children:"Before:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'/**\n * @type {HTMLElement[]}\n */\n"default": {\n\ttype: HTMLElement,\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"After:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n * @name sap.ui.webc.main.SomeComponent.prototype.default\n * @type {HTMLElement[]}\n */\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Only provide a JSDoc comment"})," and do not create a class member\nfor that slot."]}),"\n",(0,s.jsxs)(n.h4,{id:"what-about-managedslots",children:["What about ",(0,s.jsx)(n.code,{children:"managedSlots"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:["There isn't a decorator for ",(0,s.jsx)(n.code,{children:"managedSlots"})," (unlike for all other metadata entities). It is set automatically when you use\nat least one ",(0,s.jsx)(n.code,{children:"@slot"})," decorator."]}),"\n",(0,s.jsxs)(n.p,{children:["In essence, this means that if you need to access the slot content\nin your component's code, the slots automatically need to be managed.\nTherefore, whenever you use ",(0,s.jsx)(n.code,{children:"@slot"}),", the ",(0,s.jsx)(n.code,{children:"managedSlots"})," setting is automatically set."]}),"\n",(0,s.jsx)(n.h3,{id:"defining-events",children:"Defining events"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"@event"})," decorator must be used outside the class (contrary to ",(0,s.jsx)(n.code,{children:"@property"})," and ",(0,s.jsx)(n.code,{children:"@slot"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["You must provide a JSDoc ",(0,s.jsx)(n.code,{children:"@name"})," annotation with ",(0,s.jsx)(n.code,{children:"#"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'/**\n * Fired when an item is activated, unless the item\'s <code>type</code> property\n * is set to <code>Inactive</code>.\n *\n * @event sap.ui.webc.main.List#item-click\n * @allowPreventDefault\n * @param {HTMLElement} item The clicked item.\n * @public\n */\n@event("item-click", {\n\tdetail: {\n\t\titem: { type: HTMLElement },\n\t},\n})\n'})}),"\n",(0,s.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,s.jsx)(n.p,{children:"There are a couple of rules to follow when creating and using events"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Use the ",(0,s.jsx)(n.code,{children:"@event"})," decorator:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'/**\n * Fired when an item is activated, unless the item\'s <code>type</code> property\n * is set to <code>Inactive</code>.\n *\n * @event sap.ui.webc.main.List#item-click\n * @allowPreventDefault\n * @param {HTMLElement} item The clicked item.\n * @public\n */\n@event("item-click", {\n\tdetail: {\n\t\titem: { type: HTMLElement },\n\t},\n})\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Create a type for the event parameter"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type ListItemClickEventDetail {\n\titem: ListItemBase,\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Use the type when firing events"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'this.fireEvent<ListItemClickEventDetail>("item-click", { item })\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:"Export the type for the event detail"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export type { ListItemClickEventDetail };\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then, the users of your component can import the detail type and pass it to ",(0,s.jsx)(n.code,{children:"CustomEvent"}),", for example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"onItemClick(e: CustomEvent<ListItemClickEventDetail>) {\n\tconsole.log(e.detail.item);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"conventions-and-guidelines",children:"Conventions and guidelines"}),"\n",(0,s.jsx)(n.h3,{id:"conventions",children:"Conventions"}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["1. Rename ",(0,s.jsx)(n.code,{children:'"event"'})," to ",(0,s.jsx)(n.code,{children:'"e"'})," in the ",(0,s.jsx)(n.code,{children:".ts"})," files as it collides with the ",(0,s.jsx)(n.code,{children:"@event"})," decorator"]}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Since the event decorator is being imported with the ",(0,s.jsx)(n.code,{children:"event"})," keyword"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import event from "@ui5/webcomponents-base/dist/decorators/event.js";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Using the keyword ",(0,s.jsx)(n.code,{children:'"event"'})," as a parameter for our handlers leads to a collision between the parameter and the ",(0,s.jsx)(n.code,{children:"@event"})," decorator."]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Before ( which would lead to a name collision now )\n\n_onfocusin(event: FocusEvent) {\n\tconst target = event.target as ProductSwitchItem;\n\tthis._itemNavigation.setCurrentItem(target);\n\tthis._currentIndex = this.items.indexOf(target);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To avoid this and keep consistency, we decided to name the parameters in our handlers ",(0,s.jsx)(n.code,{children:'"e"'})," instead."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// After\n\n_onfocusin(e: FocusEvent) {\n\tconst target = e.target as ProductSwitchItem;\n\n\tthis._itemNavigation.setCurrentItem(target);\n\tthis._currentIndex = this.items.indexOf(target);\n}\n"})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Initialize all class members directly in the constructor."})}),"\n",(0,s.jsxs)(n.p,{children:["When creating classes, initialize ",(0,s.jsx)(n.strong,{children:"all"})," class members directly in the constructor, and not in another method, called in the constructor. This is to ensure that TypeScript understands that a class member will be always initialized, therefore is not optional. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Before \n\nclass UI5Element extends HTMLElement {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._initializeState();\n\t}\n\n\t_initializeState() {\n\t\tconst ctor = this.constructor;\n\t\tthis._state = { ...ctor.getMetadata().getInitialState() };\n\t}\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Before the change, we used to initialize ",(0,s.jsx)(n.code,{children:"_state"})," in the ",(0,s.jsx)(n.code,{children:"_initializeState"})," function. However, after the refactoring to TypeScript, we must do it directly in the constructor, otherwise it is not recognized as ",(0,s.jsx)(n.strong,{children:"always"})," initialized."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// After\n\nclass UI5Element extends HTMLElement {\n\t_state: State,\n\n\tconstructor() {\n\t\tsuper();\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tthis._state = { ...ctor.getMetadata().getInitialState() };\n\t}\n}\n"})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Create types for the Event Details."})}),"\n",(0,s.jsxs)(n.p,{children:["To enhance the quality and readability of our code, we should establish specific types for the ",(0,s.jsx)(n.code,{children:"Event Details"}),". This approach will clearly define the required ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"data"})})," for an event and optimize its usage. Without well-defined ",(0,s.jsx)(n.code,{children:"EventDetail"})," types, we may also encounter naming conflicts between similar event names in various components, leading to potential errors. Implementing ",(0,s.jsx)(n.code,{children:"EventDetail"})," types will effectively resolve this issue."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"3.1 How should we structure the name of our EventDetail type ?"})})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["To be consistent within our project, the latest convention about how we name our EventDetail types is by using the following pattern: ",(0,s.jsx)("br",{})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// File: DayPicker.ts\n\n// The pattern is \n// <<WebComponentName><EventName><EventDetail>>\n\ntype DayPickerChangeEventDetail = {\n\tdates: Array<number>,\n\ttimestamp?: number,\n}\n\nclass DayPicker extends CalendarPart implements ICalendarPicker {\n\t...\n\t_selectDate(e: Event, isShift: boolean) {\n\t\t...\n\t\tthis.fireEvent<DayPickerChangeEventDetail>("change", {\n\t\t\ttimestamp: this.timestamp,\n\t\t\tdates: this.selectedDates,\n\t\t});\n\t}\n}\n\n'})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["4. Use the syntax of ",(0,s.jsx)(n.code,{children:"Array<T>"})," instead of ",(0,s.jsx)(n.code,{children:"T[]"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["While both notations work the same way, we have chosen to utilize the ",(0,s.jsx)(n.code,{children:"Array<T>"})," notation, as opposed to ",(0,s.jsx)(n.code,{children:"T[]"}),", to maintain consistency with the notations for ",(0,s.jsx)(n.code,{children:"Map<>"})," and ",(0,s.jsx)(n.code,{children:"Record<>"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Instead of\nlet openedRegistry: RegisteredPopUpT[] = [];\n\n// We\u2019ll use\nlet openedRegistry: Array<RegisteredPopupT> = [];\n"})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"5. Use enums over object literals."})}),"\n",(0,s.jsxs)(n.p,{children:["Instead of using object literals, we have opted for ",(0,s.jsx)(n.code,{children:"enums"})," to enhance ",(0,s.jsx)(n.strong,{children:"type safety and maintainability"}),'. The use of enums provides compile-time type safety, reducing the potential for errors and making the code easier to manage. It is also important to note that all types in our "types" folder are already represented as ',(0,s.jsx)(n.code,{children:"enums"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// File: ColorConvension.ts\n\n// Instead of \n\nconst CSSColors = {\n\taliceblue: "f0f8ff",\n\tantiquewhite: "faebd7",\n\taqua: "00ffff",\n\taquamarine: "7fffd4",\n}\n\n// We\u2019ll use \n\nenum CSSColors {\n\taliceblue = "f0f8ff",\n\tantiquewhite = "faebd7",\n\taqua = "00ffff",\n\taquamarine = "7fffd4",\n}\n\n'})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["6. Use the ",(0,s.jsx)(n.code,{children:'"keyof typeof"'})," syntax when dynamically accessing objects with known keys."]})}),"\n",(0,s.jsxs)(n.p,{children:["When dynamically accessing objects with ",(0,s.jsx)(n.strong,{children:"known"})," keys, always use the ",(0,s.jsx)(n.code,{children:'"keyof typeof"'})," syntax for improved accuracy."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// File: ColorConvension.ts\n\nenum CSSColors {\n\taliceblue = "f0f8ff",\n\tantiquewhite = "faebd7",\n\taqua = "00ffff",\n\taquamarine = "7fffd4",\n}\n\u2026\n\nconst getRGBColor = (color: string): ColorRGB => {\n\t...\n\tif (color in CSSColors) {\n\t\tcolor = CSSColors[color as keyof typeof CSSColors];\n\t}\n\n\treturn HEXToRGB(color);\n};\n\n'})}),"\n",(0,s.jsx)(n.h1,{id:""}),"\n",(0,s.jsxs)(n.p,{children:["In the cases where the keys are unknown or uncertain, we use the ",(0,s.jsx)(n.code,{children:"Record<K, T>"})," notation instead of the ",(0,s.jsx)(n.code,{children:"{[key]}"})," notation.",(0,s.jsx)("br",{}),"\nIn short, ",(0,s.jsx)(n.code,{children:"Record<K, T>"})," is a TypeScript notation for describing an object with keys of ",(0,s.jsx)(n.code,{children:"type K"})," and values of ",(0,s.jsx)(n.code,{children:"type T"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// File: UI5ElementMetadata.ts\n...\ntype Metadata = {\n\ttag: string,\n\tmanagedSlots?: boolean,\n\tproperties?: Record<string, Property>,\n\tslots?: Record<string, Slot>,\n\tevents?: Array<object>,\n\tfastNavigation?: boolean,\n\tthemeAware?: boolean,\n\tlanguageAware?: boolean,\n};\n"})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:'7. Do not use "any", unless absolutely necessary.'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:'"any"'})," type instructs the TypeScript compiler to ignore type checking for a specific variable or expression. This can result in errors and make the code more complex to understand and maintain. Our ",(0,s.jsx)(n.code,{children:"ESLint"})," usually takes care of this by enforcing best practices and avoiding its usage."]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.h3,{id:"typescript-specific-guidelines",children:"TypeScript-specific guidelines"}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:'1. When to use "import type" ?'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"import"})," keyword is used to import values from a module, while ",(0,s.jsx)(n.code,{children:"import type"})," is used to import only the type information of a module without its values. This type of information can be used in type annotations and declarations."]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(n.p,{children:["For clarity, it is recommended to keep ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"type"})})," and ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"non-type"})})," imports on separate lines and explicitly mark types with the ",(0,s.jsx)(n.code,{children:"type"})," keyword, as in the following example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// This line\n\nimport I18nBundle, { getI18nBundle, I18nText } from "@ui5/webcomponents-base/dist/i18nBundle.js";\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'\n// Should be split into \n\n// Named export (function) called into the component class\nimport { getI18nBundle } from "@ui5/webcomponents-base/dist/i18nBundle.js";\n\n// Default type export.\n// Although I18nBundle is a class, it\'s used as a type of a variable.\nimport type I18nBundle from "@ui5/webcomponents-base/dist/i18nBundle.js";\n\n// Named type export, used as a type of a variable.\nimport type { I18nText } from "@ui5/webcomponents-base/dist/i18nBundle.js";\n'})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["2. When should we use the ",(0,s.jsx)(n.code,{children:'"!"'})," operator in component's file ?"]})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"!"})," operator in TypeScript is used to indicate that a value is not ",(0,s.jsx)(n.code,{children:"null"})," or ",(0,s.jsx)(n.code,{children:"undefined"})," in situations where the type checker cannot determine it."]}),"\n",(0,s.jsxs)(n.p,{children:["It is commonly used when working with the ",(0,s.jsx)(n.code,{children:"this.getDomRef()"})," and ",(0,s.jsx)(n.code,{children:"this.shadowRoot"})," properties in our web components. The return types of these properties, ",(0,s.jsx)(n.code,{children:"HTMLElement | null"})," and ",(0,s.jsx)(n.code,{children:"ShadowRoot | null"}),", respectively, are marked with ",(0,s.jsx)(n.code,{children:"null"})," because there may be instances when these values are not yet available."]}),"\n",(0,s.jsx)(n.p,{children:"This operator can also be used in other situations where TypeScript does not understand the framework's lifecycle, for example, when working with custom elements."}),"\n",(0,s.jsxs)(n.p,{children:["In short, the ",(0,s.jsx)(n.code,{children:"!"})," operator is a useful tool for ensuring that a value is not ",(0,s.jsx)(n.code,{children:"null"})," or ",(0,s.jsx)(n.code,{children:"undefined"})," in cases where the type checker cannot determine this on its own."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import UI5Element from "sap/ui/core/Element";\n\nclass Example extends UI5Element {\n\ttestProperty?: string;\n\n\tonBeforeRendering() {\n\t\tthis.testProperty = "Some text";\n\t}\n\n\tonAfterRendering() {\n\t\t// here TypeScript will complain that the testProperty may be undefined\n\t\t// in order of its definition and because it doesn\'t understand the framework\'s lifecycle\n\t\tconst varName: string = this.testProperty!;\n\t}\n}\n'})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Usage of Generics."})}),"\n",(0,s.jsx)(n.p,{children:"Generics in TypeScript help us with the creation of classes, functions, and other entities that can work with multiple types, instead of just a single one. This allows users to use their own types when consuming these entities."}),"\n",(0,s.jsxs)(n.p,{children:["Generic functions have been added to the ",(0,s.jsx)(n.code,{children:"UI5Element"}),", and a common approach for using built-in generics has been established.\nOur first generic function is the ",(0,s.jsx)(n.code,{children:"fireEvent"})," function, which uses generics to describe the event details and to check that all necessary details have been provided. The types used to describe the details provide helpful information to consumers of the event as explained above."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'fireEvent<EventDetail>("click")\n'})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:"The use of custom events as the type for the first argument of an event handler can result in TypeScript complaining about unknown properties in the details. By using generics and introducing a type for event details, we can tell TypeScript which parameters are included in the details, and thus avoid these complaints."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"handleClick(e: CustomEvent<EventDetail>)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The second use of generics is in the ",(0,s.jsx)(n.code,{children:"querySelector"}),' function. It allows us to specify a custom element return type, such as "List," while retaining the default return type of ',(0,s.jsx)(n.code,{children:"T | null."})," This allows for more precise type checking and a better understanding of the expected return value."]}),"\n",(0,s.jsxs)(n.p,{children:["It's important to note that casting the returned result will exclude \"",(0,s.jsx)(n.code,{children:"null"}),'." Additionally, if the result is always in the template and not surrounded by expressions, the "!" operator can be used.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'async _getDialog() {\n\tconst staticAreaItem = await this.getStaticAreaItemDomRef();\n\treturn staticAreaItem!.querySelector<Dialog>("[ui5-dialog]")!;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The third use case for generics is with the ",(0,s.jsx)(n.code,{children:"getFeature"})," function. This function enables us to retrieve a feature if it is ",(0,s.jsx)(n.strong,{children:"registered"}),". It is important to note that ",(0,s.jsx)(n.code,{children:"getFeature"})," returns the class definition, rather than an instance of the class. To use it effectively, the ",(0,s.jsx)(n.code,{children:"typeof"})," keyword should be utilized to obtain the class type, which will then be set as the return type of the function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'\tgetFeature<typeof FormSupportT>("FormSupport")\n'})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["4. Managing Component Styles with ",(0,s.jsx)(n.code,{children:"CSSMap"})," and ",(0,s.jsx)(n.code,{children:"ComponentStylesData"})," in the Inheritance Chain"]})}),"\n",(0,s.jsxs)(n.p,{children:["To resolve inheritance chain issues, we introduced two types that can be used in the components. All components have implemented a static ",(0,s.jsx)(n.code,{children:"get styles"})," function that returns either an array with required styles or just the component styles without an array. However, depending on the inheritance chain, TypeScript may complain about wrong return types, without considering that they will be merged into a flat array in the end."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// File: ListItem.ts\n\nstatic get styles(): ComponentStylesData {\n\treturn [ListItemBase.styles, styles];\n}\n"})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["5. Resolving the ",(0,s.jsx)(n.code,{children:"this"})," type error with TypeScript."]})}),"\n",(0,s.jsxs)(n.p,{children:["By default in Strict Mode, the type of ",(0,s.jsx)(n.code,{children:"this"})," is explicitly ",(0,s.jsx)(n.code,{children:"any"}),". When used in a global context function, as in the example, TypeScript will raise an error that ",(0,s.jsx)(n.code,{children:"this"})," has an explicit type of ",(0,s.jsx)(n.code,{children:"any"}),". To resolve this, you can add ",(0,s.jsx)(n.code,{children:"this"})," as the first argument to the function and provide its type, usually the context in which the function will be used."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type MyType = {\n\tbase: number;\n\tpow: (exponent: number) => number;\n};\n\nfunction pow(this: MyType, exponent: number) {\n\treturn Math.pow(this.base, exponent);\n}\n\nconst basePow: MyType = {\n\tbase: 2,\n\tpow,\n};\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(4041);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);