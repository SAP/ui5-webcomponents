"use strict";(self.webpackChunk_ui5_webcomponents_website=self.webpackChunk_ui5_webcomponents_website||[]).push([[7695],{70015:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var s=t(31085),i=t(71184);const o={},r="Deep dive and best practices",l={id:"docs/development/deep-dive-and-best-practices",title:"Deep dive and best practices",description:"This tutorial will cover some finer details and best practices when designing and developing UI5 Web Components.",source:"@site/docs/docs/4-development/11-deep-dive-and-best-practices.md",sourceDirName:"docs/4-development",slug:"/docs/development/deep-dive-and-best-practices",permalink:"/webcomponents/nightly/docs/development/deep-dive-and-best-practices",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{},sidebar:"documentationSidebar",previous:{title:"Testing",permalink:"/webcomponents/nightly/docs/development/testing"},next:{title:"Contributing",permalink:"/webcomponents/nightly/docs/contributing/"}},a={},d=[{value:"Metadata deep dive <a></a>",id:"metadata-deep-dive-",level:2},{value:"Tag <a></a>",id:"tag-",level:3},{value:"Properties <a></a>",id:"properties-",level:3},{value:"Properties are managed state",id:"properties-are-managed-state",level:4},{value:"Properties vs attributes",id:"properties-vs-attributes",level:4},{value:"Public vs private properties",id:"public-vs-private-properties",level:4},{value:"Property types and default values",id:"property-types-and-default-values",level:4},{value:"Best practices for using properties",id:"best-practices-for-using-properties",level:4},{value:"Metadata properties vs standard JS properties",id:"metadata-properties-vs-standard-js-properties",level:4},{value:"Events",id:"events",level:2},{value:"Describing the Event",id:"describing-the-event",level:3},{value:"Firing the Event",id:"firing-the-event",level:3},{value:"The <code>fireEvent</code> method",id:"the-fireevent-method",level:4},{value:"The <code>fireDecoratorEvent</code> method",id:"the-firedecoratorevent-method",level:4},{value:"Describing the Event Detail",id:"describing-the-event-detail",level:3},{value:"Handling Events in Templates",id:"handling-events-in-templates",level:3},{value:"Preventable Events",id:"preventable-events",level:3},{value:"Slots",id:"slots",level:2},{value:"Slot as Class Member",id:"slot-as-class-member",level:3},{value:"Default and Named Slot",id:"default-and-named-slot",level:3},{value:"Individual Slots",id:"individual-slots",level:3},{value:"Invalidation on Child Change",id:"invalidation-on-child-change",level:3},{value:"Styling of Slotted Children",id:"styling-of-slotted-children",level:3},{value:"Understanding rendering",id:"understanding-rendering",level:2},{value:"What is rendering? <a></a>",id:"what-is-rendering-",level:3},{value:"Physical and logical components <a></a>",id:"physical-and-logical-components-",level:3},{value:"What is invalidation? <a></a>",id:"what-is-invalidation-",level:3},{value:"Lifecycle hooks",id:"lifecycle-hooks",level:2},{value:"<code>constructor</code>",id:"constructor",level:3},{value:"<code>onBeforeRendering</code>",id:"onbeforerendering",level:3},{value:"<code>onAfterRendering</code>",id:"onafterrendering",level:3},{value:"<code>onEnterDOM</code> and <code>onExitDOM</code>",id:"onenterdom-and-onexitdom",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"deep-dive-and-best-practices",children:"Deep dive and best practices"}),"\n",(0,s.jsx)(n.p,{children:"This tutorial will cover some finer details and best practices when designing and developing UI5 Web Components."}),"\n",(0,s.jsxs)(n.h2,{id:"metadata-deep-dive-",children:["Metadata deep dive ",(0,s.jsx)("a",{name:"metadata"})]}),"\n",(0,s.jsx)(n.p,{children:"The metadata defines the public API of your component. Among other things, here you define:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"the tag name"}),"\n",(0,s.jsx)(n.li,{children:"what properties/attributes (and of what type) your component supports"}),"\n",(0,s.jsx)(n.li,{children:"what slots your component supports"}),"\n",(0,s.jsx)(n.li,{children:"what events your component fires"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"tag-",children:["Tag ",(0,s.jsx)("a",{name:"metadata_tag"})]}),"\n",(0,s.jsxs)(n.p,{children:["The tag name must include a ",(0,s.jsx)(n.code,{children:"-"})," as required for any custom element. The tag is declared using ",(0,s.jsx)(n.code,{children:"@customElement"})," decorator:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@custom("my-component")\n//or\n@custom({\n\ttag: "my-component"\n})\n'})}),"\n",(0,s.jsx)(n.p,{children:"and then the usage is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<my-component></my-component>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"tag"}),', as defined is referred to as the "pure tag", meaning it is not suffixed (scoping is not used).']}),"\n",(0,s.jsxs)(n.p,{children:["Important: the pure tag name of every UI5 Web Component is always set as an ",(0,s.jsx)(n.strong,{children:"attribute"})," to the component too."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, when you create a ",(0,s.jsx)(n.code,{children:"ui5-button"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<ui5-button id="b1" class="button1" design="Emphasized"></ui5-button>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["the framework will create an empty attribute with the name ",(0,s.jsx)(n.code,{children:"ui5-button"})," too, so the actual DOM would look like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<ui5-button id="b1" class="button1" design="Emphasized" ui5-button></ui5-button>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Even if a suffix for tag names is configured (when scoping is enabled), the attribute with the pure tag name will be the same."}),"\n",(0,s.jsxs)(n.p,{children:["For example, if the configured suffix is ",(0,s.jsx)(n.code,{children:"-demo"})," and all components are used with this suffix:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<ui5-button-demo id="b1" class="button1" design="Emphasized" ui5-button></ui5-button-demo>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["the ",(0,s.jsx)(n.strong,{children:"attribute"})," will still be the same (",(0,s.jsx)(n.code,{children:"ui5-button"})," as opposed to the tag name of ",(0,s.jsx)(n.code,{children:"ui5-button-demo"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"Therefore, the best practice when developing UI5 Web Components is to write CSS selectors for the shadow roots using\nattribute selectors, instead of tag selectors."}),"\n",(0,s.jsxs)(n.p,{children:["For example, if the ",(0,s.jsx)(n.code,{children:"MyComponentTemplate.tsx"})," file looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export default function MyComponentTemplate() {\n    return (\n       <div class="my-component">\n\t\t\t<Button id="openBtn">Open</Button>\n\t\t\t<div>\n\t\t\t\t<slot></slot>\n\t\t\t</div>\n\t\t\t<List></List>\n\t\t</div>\n    );\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["you should not write selectors by tag name for other components in the ",(0,s.jsx)(n.code,{children:"Demo.css"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:"ui5-button {\n\twidth: 50px;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"because, as stated above, the tag name could be suffixed and is not guaranteed to always be the same as the pure tag name."}),"\n",(0,s.jsx)(n.p,{children:"Instead, use the attribute selector:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:"[ui5-button] {\n\twidth: 50px;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"or another type of selector (for example by ID):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:"#openBtn {\n\twidth: 50px;\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"properties-",children:["Properties ",(0,s.jsx)("a",{name:"metadata_properties"})]}),"\n",(0,s.jsx)(n.h4,{id:"properties-are-managed-state",children:"Properties are managed state"}),"\n",(0,s.jsxs)(n.p,{children:["The framework will create a getter/setter pair on your component's prototype for each property, defined with ",(0,s.jsx)(n.code,{children:"@property"})," decorator."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, defining ",(0,s.jsx)(n.code,{children:"text"})," property:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@property()\ntext = ""\n'})}),"\n",(0,s.jsxs)(n.p,{children:["you can use the ",(0,s.jsx)(n.code,{children:"text"})," getter/setter on this component's instances:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'let t = myComponent.text;\nmyComponent.text = "New text";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Whenever ",(0,s.jsx)(n.code,{children:"text"})," is read or set, the framework-defined getter/setter will be called and thus the framework will be in control of the property."]}),"\n",(0,s.jsx)(n.h4,{id:"properties-vs-attributes",children:"Properties vs attributes"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"properties"})," defined via the ",(0,s.jsx)(n.code,{children:"@property"})," decorator results in both properties and attributes for your component. By default, for each property (",(0,s.jsx)(n.code,{children:"camelCase"})," name) an attribute with the\nsame name but in ",(0,s.jsx)(n.code,{children:"kebab-case"})," is supported. Properties of type ",(0,s.jsx)(n.code,{children:"Object"})," have no attribute counterparts. If you wish to not have an attribute for a given property regardless of type, you can configure it with ",(0,s.jsx)(n.code,{children:"noAttribute: true"})," setting."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, defining ",(0,s.jsx)(n.code,{children:"headerText"})," property:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@property()\nheaderText = ""\n'})}),"\n",(0,s.jsxs)(n.p,{children:["you can use both the ",(0,s.jsx)(n.code,{children:"headerText"})," property and ",(0,s.jsx)(n.code,{children:"header-text"})," attribute:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'let t = myComponent.text;\nmyComponent.headerText = "New text";\nmyComponent.setAttrbite("header-text", "New text");\n'})}),"\n",(0,s.jsx)(n.h4,{id:"public-vs-private-properties",children:"Public vs private properties"}),"\n",(0,s.jsxs)(n.p,{children:["The framework does not distinguish between ",(0,s.jsx)(n.em,{children:"public"})," and ",(0,s.jsx)(n.em,{children:"private"})," properties. You can treat some properties as private in a sense that you can document them as such and not advertise them to users.\nThe usual convention is that private properties start with an ",(0,s.jsx)(n.code,{children:"_"}),", but this is not mandatory. In the end, all properties defined in the metadata, public or private,\nare ",(0,s.jsx)(n.em,{children:"component state"}),", therefore cause the component to be invalidated and subsequently re-rendered, when changed."]}),"\n",(0,s.jsx)(n.h4,{id:"property-types-and-default-values",children:"Property types and default values"}),"\n",(0,s.jsxs)(n.p,{children:["The most common types of properties are ",(0,s.jsx)(n.code,{children:"String"}),", ",(0,s.jsx)(n.code,{children:"Boolean"}),", ",(0,s.jsx)(n.code,{children:"Object"}),"and ",(0,s.jsx)(n.code,{children:"Number"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Most property types can have a default value, but ",(0,s.jsx)(n.code,{children:"Boolean "}),"properties should always default to ",(0,s.jsx)(n.code,{children:"false"}),". When a boolean attribute is absent, it's treated as false, therefore, the default value of an attribute must be always false."]}),"\n",(0,s.jsx)(n.p,{children:"For example, defining different types of properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'class MyComponent extends UI5Element {\n\t@property()\n\ttext = "Hello";\n\n\t@property({ type: Number, noAttribute: true })\n\twidth = 1024;\n\n\t@property({ type: Number })\n\tscale = 0.5;\n\n\t@property({ type: Object })\n\tdata = {};\n\n\t/**\n\t * @private\n\t */\n\t@property({ type: Boolean })\n\t_isPhone = false;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here ",(0,s.jsx)(n.code,{children:"text"}),", ",(0,s.jsx)(n.code,{children:"width"}),", ",(0,s.jsx)(n.code,{children:"scale"})," and ",(0,s.jsx)(n.code,{children:"data"})," are public properties, and ",(0,s.jsx)(n.code,{children:"_isPhone"})," private, but only by convention. If the user (or the component internally) changes any of these properties, the component will be invalidated."]}),"\n",(0,s.jsx)(n.h4,{id:"best-practices-for-using-properties",children:"Best practices for using properties"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"\u0410void directly modifying public properties"})," from within a component, as these properties are typically controlled by the parent application. The only exception to this rule is when the property change results directly from user interaction (e.g., updating a value after a user types in an input field, or toggling a checked property after a user clicks a checkbox). Additionally, whenever you modify a public property due to user interaction, it's important to ",(0,s.jsx)(n.strong,{children:"fire an event"})," to notify the parent application. This ensures that the application can synchronize its state accordingly."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["As for private properties, the best practice is to ",(0,s.jsx)(n.strong,{children:"only"})," change them internally and never let the application know about their existence."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Using attribute selectors instead of setting and using CSS classes on your component. Both public and private properties are great ways to create CSS selectors for your component with the ",(0,s.jsx)(n.code,{children:":host()"})," selector. The ",(0,s.jsx)(n.code,{children:":host()"})," selector targets the custom element itself, and can be combined with other selectors."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For example, using the ",(0,s.jsx)(n.code,{children:"size"})," property (respectively the attribute with the same name) to change component's dimensions for certain values - ",(0,s.jsx)(n.code,{children:'size="XS"'}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:':host {\n\theight: 5rem;\n\twidth: 5rem;\n}\n\n:host([size="XS"]) {\n\theight: 2rem;\n\twidth: 2rem;\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<my-comopnent size="XS"></my-comopnent> \x3c!-- :host() targets my-component --\x3e\n'})}),"\n",(0,s.jsx)(n.h4,{id:"metadata-properties-vs-standard-js-properties",children:"Metadata properties vs standard JS properties"}),"\n",(0,s.jsxs)(n.p,{children:["It is important not to confuse properties defined with ",(0,s.jsx)(n.code,{children:"@property"})," decorator  with regular Javascript properties.\nYou can create any number of properties on your component's instance, f.e.:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"constructor() {\n\tsuper();\n\tthis._isMobile = false;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"However, only metadata-defined properties are managed by the framework: cause invalidation and are converted to/from attributes.\nFeel free to create as many regular JS properties for the purpose of your component's functionality as you need, but bear in mind\nthat they will not be managed by the framework."}),"\n",(0,s.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,s.jsx)(n.p,{children:"Most UI5 components emit events to inform the application about user interactions. Defining and firing events involves several key aspects:"}),"\n",(0,s.jsx)(n.h3,{id:"describing-the-event",children:"Describing the Event"}),"\n",(0,s.jsxs)(n.p,{children:["Use the ",(0,s.jsx)(n.code,{children:"@event"})," decorator to define the event. If the event name consists of multiple words, use kebab-case:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@event("selection-change", {\n\tdetail: {\n\t\tvalid: { type: Boolean },\n\t},\n})\nclass MyComponent extends UI5Element {\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"firing-the-event",children:"Firing the Event"}),"\n",(0,s.jsxs)(n.h4,{id:"the-fireevent-method",children:["The ",(0,s.jsx)(n.code,{children:"fireEvent"})," method"]}),"\n",(0,s.jsxs)(n.p,{children:["Use the ",(0,s.jsx)(n.code,{children:"UI5Element#fireEvent"})," method to trigger the event:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@event("selection-change", {\n\tdetail: {\n\t\tvalid: { type: Boolean },\n\t},\n})\nclass MyComponent extends UI5Element {\n\tonItemSelected(e: Event) {\n\t\tthis.fireEvent("selection-change", {\n\t\t\tvalid: true,\n\t\t});\n\t}\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["By defualt when using ",(0,s.jsx)(n.code,{children:"fireEvent"})," it assumes the event is bubbling (bubbles: true) and not preventable (cancelable: false)."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fire event with default configuration"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// Fires the event as NOT preventable and bubbling\nthis.fireEvent("change");\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fire event with non-default configuration"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The method allows configuring the ",(0,s.jsx)(n.code,{children:"cancelable"})," and ",(0,s.jsx)(n.code,{children:"bubbles"})," fields via function arguments - the third and fourth parameters respectively."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// Fires the event as preventable and non-bubbling\nthis.fireEvent("change", {}, true, false);\n'})}),"\n",(0,s.jsxs)(n.h4,{id:"the-firedecoratorevent-method",children:["The ",(0,s.jsx)(n.code,{children:"fireDecoratorEvent"})," method"]}),"\n",(0,s.jsxs)(n.p,{children:["Use the ",(0,s.jsx)(n.code,{children:"UI5Element#fireDecoratorEvent"})," method to trigger the event."]}),"\n",(0,s.jsxs)(n.p,{children:["The method is available since version ",(0,s.jsx)(n.code,{children:"v2.4.0"})," and it is similar to ",(0,s.jsx)(n.code,{children:"fireEvent"}),". It fires a custom event, but gets the configuration for the event from the ",(0,s.jsx)(n.code,{children:"@event"})," decorator. In case you rely on the decorator settings, you must use the ",(0,s.jsx)(n.code,{children:"fireDecoratorEvent"})," method."]}),"\n",(0,s.jsxs)(n.p,{children:["Keep in mind that ",(0,s.jsx)(n.code,{children:"cancelable"})," and ",(0,s.jsx)(n.code,{children:"bubbles"})," are ",(0,s.jsx)(n.code,{children:"false"})," by default and you must explicitly enable them in the ",(0,s.jsx)(n.code,{children:"@event"})," decorator if required."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fire event with default configuration"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@event("change")\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// Fires the event as NOT preventable and NOT bubbling\nthis.fireDecoratorEvent("change");\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fire event with non-default configuration"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@event("change", {\n    bubbles: true // false by default\n    cancelable: true // false by default\n})\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// Fires the event as preventable and bubbling\nthis.fireDecoratorEvent("change");\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," since ",(0,s.jsx)(n.code,{children:"v2.4.0"})," it's recommended to describe the event in the ",(0,s.jsx)(n.code,{children:"@event"})," decorator and use the ",(0,s.jsx)(n.code,{children:"fireDecoratorEvent"})," method."]}),"\n",(0,s.jsx)(n.h3,{id:"describing-the-event-detail",children:"Describing the Event Detail"}),"\n",(0,s.jsxs)(n.p,{children:["When an event includes a detail it's recommended to create a TypeScript type that describes the event detail and use it in the ",(0,s.jsx)(n.code,{children:"fireEvent"})," or ",(0,s.jsx)(n.code,{children:"fireDecoratorEvent"}),' (as generic methods) to force static checks ensuring that proper event detail is passed.\nThe naming convention for the type is a combination of the component class name ("MyComponent"), the event name ("SelectionChange"), followed by "EventDetail", written in PascalCase, e.g "MyComponentSelectionChangeEventDetail":']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'export type MyComponentSelectionChangeEventDetail = {\n\tvalid: boolean;\n};\n\n\n@event<MyComponentSelectionChangeEventDetail>("selection-change", {\n\tdetail: {\n\t\tvalid: { type: Boolean },\n\t},\n})\nclass MyComponent extends UI5Element {\n\n\tonItemSelected(e: Event) {\n\t\tthis.fireDecoratorEvent<MyComponentSelectionChangeEventDetail>("selection-change", {\n\t\t\tvalid: true,\n\t\t});\n\t}\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," it's a best practice to export the type to make it available for outside usage."]}),"\n",(0,s.jsx)(n.h3,{id:"handling-events-in-templates",children:"Handling Events in Templates"}),"\n",(0,s.jsxs)(n.p,{children:["When attaching event handlers within your component's template for events fired by other web components, use the ",(0,s.jsx)(n.code,{children:"on"})," prefix + the event name in ",(0,s.jsx)(n.code,{children:"PascalCase"}),".\nFor example, if a ui5-list component emits a ",(0,s.jsx)(n.code,{children:"selection-change"})," event, in the template attach ",(0,s.jsx)(n.code,{children:"onSelectionChange"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// DemoTemplate.tsx\nexport default function MyComponentTemplate() {\n    return <div class="my-component">\n\t\t<List onSelectionChange={this.onSelectionChange}></List>\n\t</div>;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["By default, events are fired in pairs: one with the standard name and another prefixed with ",(0,s.jsx)(n.code,{children:"ui5-"}),". While the ",(0,s.jsx)(n.code,{children:"ui5-"})," prefixed event is always emitted, the non-prefixed event can be suppressed if the ",(0,s.jsx)(n.code,{children:"noConflict"})," configuration setting is enabled. In this case, only the prefixed event will be triggered. For more details on the ",(0,s.jsx)(n.code,{children:"noConflict"})," setting, refer to the ",(0,s.jsx)(n.a,{href:"/webcomponents/nightly/docs/advanced/configuration",children:"Configuration"})," section."]}),"\n",(0,s.jsx)(n.h3,{id:"preventable-events",children:"Preventable Events"}),"\n",(0,s.jsxs)(n.p,{children:["It's common to prevent certain events in an application. You must configure the ",(0,s.jsx)(n.code,{children:"cancelable"})," setting in the ",(0,s.jsx)(n.code,{children:"@event"})," decorator to make the event preventable."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@event("change", {\n    cancelable: true // false by default\n})\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You most likely will need to update (or revert) the component's state when an event is prevented by the consuming side. To determine if an event was prevented, check the return value of the ",(0,s.jsx)(n.code,{children:"fireDecoratorEvent"})," method. It returns false if the event was cancelled (",(0,s.jsx)(n.code,{children:"preventDefault"})," was called) and true otherwise:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@event("change", {\n    cancelable: true // false by default\n})\nclass Switch extends UI5Element {\n\ttoggle() {\n\t\tthis.checked = !this.checked;\n\t\tconst changePrevented = !this.fireDecoratorEvent("change");\n\n\t\tif (changePrevented) {\n\t\t\tthis.checked = !this.checked;\n\t\t}\n\t}\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"slots",children:"Slots"}),"\n",(0,s.jsxs)(n.p,{children:["Web Components offer a ",(0,s.jsx)(n.code,{children:"slot"})," mechanism for component composition, allowing components to render children\nor other components in specific locations within their shadow root."]}),"\n",(0,s.jsxs)(n.p,{children:["To enable slotting for your component, simply add a ",(0,s.jsx)(n.code,{children:"<slot>"})," element within your template.\nThis acts as a placeholder that can be filled with any HTML markup."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export default function MyComponentTemplate() {\n\treturn (\n\t\t<div class="my-component-root">\n\t\t\t<slot></slot>\n\t\t</div>\n\t);\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"On the consuming side, you can insert HTML elements into your component:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"\x3c!-- index.html --\x3e\n<my-component>\n\t<span>Hello World</span>\n</my-component>\n"})}),"\n",(0,s.jsx)(n.p,{children:"For documentation purposes and to inform component consumers about the available slot,\nwe should describe it with a brief JSDoc comment at component class level as shown below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'/*\n * @slot {Array<Node>} default - Defines the content of the component.\n */\n@customElement({\n\ttag: "ui5-demo-component",\n})\nclass MyComponent extends UI5Element {}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"slot-as-class-member",children:"Slot as Class Member"}),"\n",(0,s.jsxs)(n.p,{children:["We can define our slots as class members via the ",(0,s.jsx)(n.code,{children:"@slot"})," decorator as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import slot from "@ui5/webcomponents-base/dist/decorators/slot.js";\n\n@customElement("my-component")\nclass MyComponent extends UI5Element {\n\t@slot()\n\titems!: Array<HTMLElement>;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Defining a slot with the ",(0,s.jsx)(n.code,{children:"@slot"})," decorator means that this slot will be managed by the framework:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If any of the children are custom elements, the framework will wait until they are all defined and upgraded before rendering the component."}),"\n",(0,s.jsx)(n.li,{children:"The component will be re-rendered when its children are added, removed, or rearranged."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Also, we define slots as class members when we need to access the slotted children for some reason.\nFor example, to get the slotted elements count:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const itemsCount = this.items.length;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or, to read some state of the slotted elements:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const hasDisabledItem = this.items.some(el => el.disabled);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or, sometimes even set some private state on the slotted elements:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"this.items.forEach((item, key) => {\n\tconst isLastChild = key === this.items.length - 1;\n\titem.showBorder = isLastChild;\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["All slots, declared with the ",(0,s.jsx)(n.code,{children:"@slot"})," decorator, are arrays with elements of type Node or HTMLElement.\nSo, you can safely and ",(0,s.jsx)(n.strong,{children:"must"})," declare slots (by convention) with ",(0,s.jsx)(n.code,{children:"!:"})," as the accessor will return an empty array in the worst case."]}),"\n",(0,s.jsx)(n.p,{children:"Also, when you declare slots as class members, you can document them in place - you don't need to describe them at class level as mentioned in the previous section."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n * Defines the items of the component.\n * @public\n */\n@slot()\nitems: Array<HTMLElement>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"default-and-named-slot",children:"Default and Named Slot"}),"\n",(0,s.jsxs)(n.p,{children:["Default slot is the one that can be used without setting the ",(0,s.jsx)(n.code,{children:"slot"})," attribute of the slotted elements, while\nnamed slot requires setting the ",(0,s.jsx)(n.code,{children:"slot"})," attribute:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Default slot"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export default function MyComponentTemplate() {\n\treturn (\n\t\t<div class="my-component-root">\n\t\t\t<slot></slot>\n\t\t</div>\n\t);\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"\x3c!-- index.html --\x3e\n<my-component>\n\t<span>Hello World</span>\n</my-component>\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Named slot"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The named slot requires a small change in the component's template. You must pass the ",(0,s.jsx)(n.code,{children:"name"})," attrbite to the ",(0,s.jsx)(n.code,{children:"slot"})," element:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// DemoTemplate.tsx\nexport default function () {\n\treturn (\n\t\t<div class="my-component-root">\n\t\t\t<slot name="content"></slot>\n\t\t</div>\n\t);\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'\x3c!-- index.html --\x3e\n<my-component>\n\t<span slot="content">Hello World</span>\n</my-component>\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Declare default slot"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["All slots are named if you simply use the ",(0,s.jsx)(n.code,{children:"@slot"})," decorator without any settings, while the default slots must be explicitly marked as such with the ",(0,s.jsx)(n.code,{children:'"default"'})," setting:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import slot from "@ui5/webcomponents-base/dist/decorators/slot.js";\n\n@customElement("my-component")\nclass MyComponent extends UI5Element {\n\t@slot({ type: HTMLElement, "default": true })\n\tcontent!: Array<HTMLElement>;\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Declare named slot"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Simply use the ",(0,s.jsx)(n.code,{children:"@slot"})," decorator without any settings:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import slot from "@ui5/webcomponents-base/dist/decorators/slot.js";\n\n@customElement("my-component")\nclass MyComponent extends UI5Element {\n\t@slot()\n\tcontent!: Array<HTMLElement>;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"It's a good practice is to make use of the default slot as it requires less code to use your component.\nAnd, if your component has multiple slots - to pick the most important and used one as the default."}),"\n",(0,s.jsx)(n.p,{children:'For example, here we assume that the "content" slot is more important and we declared it as default.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export default function MyComponentTemplate() {\n\treturn (\n\t\t<div class="my-component-root">\n\t\t\t<div class="my-component-heading">\n\t\t\t\t<slot name="heading"></slot>\n\t\t\t</div>\n\n\t\t\t<slot></slot>\n\t\t</div>\n\t);\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'\x3c!-- index.html --\x3e\n<my-component>\n\t<h1 slot="heading">Heading</h1>\n\t<span>Hello World</span>\n</my-component>\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import slot from "@ui5/webcomponents-base/dist/decorators/slot.js";\n\n@customElement("my-component")\nclass MyComponent extends UI5Element {\n\t@slot({ type: HTMLElement, "default": true })\n\tcontent!: Array<HTMLElement>;\n\n\t@slot()\n\theading!: Array<HTMLElement>;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," If the slot configuration object is not provided (e.g. ",(0,s.jsx)(n.code,{children:"@slot()"}),"), ",(0,s.jsx)(n.code,{children:"HTMLElement"})," will be used as the default type.\nHowever, if you provide this object, the ",(0,s.jsx)(n.code,{children:"type"})," field is mandatory."]}),"\n",(0,s.jsx)(n.h3,{id:"individual-slots",children:"Individual Slots"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"@slot"})," decorator provides an option called ",(0,s.jsx)(n.code,{children:"individualSlots"}),", which is of boolean type. This option determines if each child element will be placed in its own slot, allowing for flexible arrangement or wrapping of the children within the component. When ",(0,s.jsx)(n.code,{children:"individualSlots"})," is enabled, the framework assigns a unique ",(0,s.jsx)(n.code,{children:"_individualSlot"})," property to each child element. This property can then be used within the component's template, as shown in the following example."]}),"\n",(0,s.jsxs)(n.p,{children:["First, enable ",(0,s.jsx)(n.code,{children:"individualSlots"})," by setting it to ",(0,s.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import slot from "@ui5/webcomponents-base/dist/decorators/slot.js";\n\n@customElement("my-component")\nclass MyComponent extends UI5Element {\n\t@slot({ type: HTMLElement, individualSlots: true })\n\tcontent!: Array<HTMLElement>;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Next, iterate over the child elements in the template, using the ",(0,s.jsx)(n.code,{children:"_individualSlot"})," property in the name attribute of the slot element:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"export default function MyComponentTemplate() {\n\treturn (\n\t\t<div>\n\t\t\t{ this.content.map(contentEl => <slot name={contentEl._individualSlot}></slot>)}\n\t\t</div>\n\t);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here is an example using the ",(0,s.jsx)(n.code,{children:"Carousel"})," web component, which leverages ",(0,s.jsx)(n.code,{children:"individualSlots"})," to wrap each slotted child within the content slot to achieve a specific design:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import slot from "@ui5/webcomponents-base/dist/decorators/slot.js";\n\n@customElement("ui5-carousel")\nclass Carousel extends UI5Element {\n\t@slot({ type: HTMLElement, individualSlots: true })\n\tcontent!: Array<HTMLElement>;\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export default function CarouselTemplate(this: Carousel) {\n\treturn (\n\t\t<div>\n\t\t\t{ this.content.map(contentEl =>\n\t\t\t\t<div\n\t\t\t\t\tclass="ui5-carousel-item"\n\t\t\t\t\trole="option"\n\t\t\t\t\taria-posinset={contentEl.posinset}\n\t\t\t\t\taria-setsize={contentEl.setsize}\n\t\t\t\t\taria-selected={contentEl.selected}\n\t\t\t\t>\n\t\t\t\t\t<slot name={contentEl.item._individualSlot}></slot>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": When ",(0,s.jsx)(n.code,{children:"individualSlots"})," is enabled, the ",(0,s.jsx)(n.code,{children:"_individualSlot"})," property is assigned to each direct child. The value of ",(0,s.jsx)(n.code,{children:"_individualSlot"})," follows the pattern ",(0,s.jsx)(n.code,{children:"{nameOfTheSlot}-{index}"}),", and the slot attribute is updated accordingly."]}),"\n",(0,s.jsx)(n.h3,{id:"invalidation-on-child-change",children:"Invalidation on Child Change"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"@slot"})," decorator offers an ",(0,s.jsx)(n.code,{children:"invalidateOnChildChange"})," option, which can be set as a boolean or a configuration object. This option determines whether a component should be invalidated when changes occur within its child elements."]}),"\n",(0,s.jsxs)(n.p,{children:["By default, if child elements are added or removed from a slot, the component will be invalidated automatically. The ",(0,s.jsx)(n.code,{children:"invalidateOnChildChange"})," option goes a step further by triggering invalidation even when properties or slots of the child elements change. This is useful if the state of parent component depends on the state of its children."]}),"\n",(0,s.jsxs)(n.p,{children:["The simplest way to use this option is to set ",(0,s.jsx)(n.code,{children:"invalidateOnChildChange"})," to ",(0,s.jsx)(n.code,{children:'"true"'}),". This configuration ensures that the ",(0,s.jsx)(n.code,{children:"my-component"})," web component will be invalidated whenever any of the UI5Element instances slotted into the content slot are updated, whether due to a property or slot change."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import slot from "@ui5/webcomponents-base/dist/decorators/slot.js";\n\n@customElement("my-component")\nclass MyComponent extends UI5Element {\n    @slot({ type: HTMLElement, invalidateOnChildChange: true })\n    content!: Array<HTMLElement>;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For more specific scenarios, you can use a more detailed configuration. The following example demonstrates how to invalidate the ",(0,s.jsx)(n.code,{children:'"my-component"'}),' web component only when certain properties or slots of the slotted UI5Element instances change. In this case, the component will be invalidated if the "myProp" property or the "mySlot" slot of the child elements are modified.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import slot from "@ui5/webcomponents-base/dist/decorators/slot.js";\n\n@customElement("my-component")\nclass MyComponent extends UI5Element {\n\t@slot({ type: HTMLElement, invalidateOnChildChange: { properties: ["myProp"], slots: ["mySlot"] }})\n\tcontent!: Array<HTMLElement>;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"invalidateOnChildChange"}),' option is especially useful when working with "abstract" elements option is particularly useful when dealing with "abstract" elements, such as UI5Element instances that do not have their own templates. In these cases, the parent component is responsible for rendering the content based on the state of its child elements.']}),"\n",(0,s.jsxs)(n.p,{children:["For instance, consider a ",(0,s.jsx)(n.code,{children:"Wizard"})," web component that accepts ",(0,s.jsx)(n.code,{children:"WizardStep"})," elements in its ",(0,s.jsx)(n.code,{children:'"steps"'})," slot. Since ",(0,s.jsx)(n.code,{children:"WizardStep"})," does not have its own template, the ",(0,s.jsx)(n.code,{children:"Wizard"})," must handle rendering based on the properties and state of the steps. Therefore, the ",(0,s.jsx)(n.code,{children:"Wizard"})," needs to be invalidated whenever any changes occur within its child elements to ensure proper rendering."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'class Wizard extends UI5Element {\n\t@slot({\n\t\t"default": true,\n\t\ttype: HTMLElement,\n\t\tinvalidateOnChildChange: true,\n\t})\n\tsteps!: Array<WizardStep>\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<ui5-wizard>\n\t<ui5-wizard-step title-text="Product type" icon="sap-icon://product" selected></ui5-wizard-step>\n\t<ui5-wizard-step title-text="Options"></ui5-wizard-step>\n\t<ui5-wizard-step title-text="Pricing" disabled></ui5-wizard-step>\n</ui5-wizard>\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export default function WizardTemplate(this: Wizard) {\n\treturn (\n\t\t<div>\n\t\t\t{ this._steps.map(step =>\n\t\t\t\t<div class="ui5-wiz-step-root"></div>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": The ",(0,s.jsx)(n.code,{children:"invalidateOnChildChange"})," option is meant to be used with slots that are UI5Element instances."]}),"\n",(0,s.jsx)(n.h3,{id:"styling-of-slotted-children",children:"Styling of Slotted Children"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:":slotted"})," CSS selector applies to any element that has been placed into a slot.\nIt works when used inside CSS placed within the shadow DOM of the component that offers the slot."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'\x3c!-- index.html --\x3e\n<my-component>\n\t<h1 slot="heading">Heading</h1>\n\t<span>Hello World</span>\n</my-component>\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:'/* MyComponent.css */\n::slotted([slot="heading"]) {\n\twidth: 200px;\n\theight: 100px;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"understanding-rendering",children:"Understanding rendering"}),"\n",(0,s.jsxs)(n.h3,{id:"what-is-rendering-",children:["What is rendering? ",(0,s.jsx)("a",{name:"rendering_def"})]}),"\n",(0,s.jsxs)(n.p,{children:["In the context of UI5 Web Components the notion of ",(0,s.jsx)(n.strong,{children:"rendering"})," means ",(0,s.jsx)(n.strong,{children:"creating the content of a shadow root"})," (building the shadow DOM)."]}),"\n",(0,s.jsxs)(n.h3,{id:"physical-and-logical-components-",children:["Physical and logical components ",(0,s.jsx)("a",{name:"rendering_physical_logical"})]}),"\n",(0,s.jsxs)(n.p,{children:["Each component that has a ",(0,s.jsx)(n.code,{children:"template"})," described in ",(0,s.jsx)(n.code,{children:"@customElement"})," decorator will be rendered (will have its shadow DOM built) initially and every time it gets invalidated."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import MyComponentTemplate from "./generated/templates/MyComponentTemplate.lit.js";\n\n@customElement({\n\ttemplate: MyComponentTemplate\n})\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Components that do not have ",(0,s.jsx)(n.code,{children:"template"})," defined in ",(0,s.jsx)(n.code,{children:"@customElement"})," decorator are considered ",(0,s.jsx)(n.em,{children:"logical"})," or ",(0,s.jsx)(n.em,{children:"marker"})," elements only. These components are never rendered (do not have a shadow root at all)\nand their only purpose is to serve as items for higher-order components. The classical example of a logical component is a select option."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<ui5-calendar>\n\t<ui5-date></ui5-date>\n</ui5-calendar>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ui5-date"})," component does not have template, and is therefore never rendered. However, the ",(0,s.jsx)(n.code,{children:"ui5-calendar"})," component, which is a physical component that has a template,\nrenders HTML corresponding to each of its children (",(0,s.jsx)(n.code,{children:"ui5-date"})," instances) as part of its own shadow DOM."]}),"\n",(0,s.jsxs)(n.h3,{id:"what-is-invalidation-",children:["What is invalidation? ",(0,s.jsx)("a",{name:"invalidation"})]}),"\n",(0,s.jsx)(n.p,{children:"Invalidation means scheduling an already rendered component for asynchronous re-rendering (in the next animation frame). If an already invalidated component gets changed\nagain, before having been re-rendered, this will have no downside - it's in the queue of components to be re-rendered anyway."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important:"})," when a component is re-rendered, only the parts of its shadow DOM, dependent on the changed properties/slots are changed, which makes most updates very fast."]}),"\n",(0,s.jsxs)(n.p,{children:["A component becomes ",(0,s.jsx)(n.em,{children:"invalidated"})," whenever:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["a ",(0,s.jsx)(n.em,{children:"metadata-defined"})," ",(0,s.jsx)(n.strong,{children:"property"})," changes (not regular properties that f.e. you define in the constructor)"]}),"\n",(0,s.jsxs)(n.li,{children:["children are added/removed/rearranged in any ",(0,s.jsx)(n.strong,{children:"slot"})," declared with ",(0,s.jsx)(n.code,{children:"@slot"})," decorator."]}),"\n",(0,s.jsxs)(n.li,{children:["a slotted child in a ",(0,s.jsx)(n.strong,{children:"slot"})," configured with ",(0,s.jsx)(n.code,{children:"invalidateOnChildChange: true"})," is invalidated."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Changes to properties always cause an invalidation. No specific metadata configuration is needed."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"@property()\ntext?: string;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Whenever ",(0,s.jsx)(n.code,{children:"text"})," changes, the component will be invalidated."]}),"\n",(0,s.jsx)(n.p,{children:"As we defined earlier there two kind of slots - unnamed and named. Unnamed slots do not cause an invalidation. Most components do not need to render differently based on whether they have any slotted children or not. This component will not invalidate when children are added/removed from any of its unnamed slots."}),"\n",(0,s.jsxs)(n.p,{children:["However, some components render differently based on whether they have children or not (e.g. show counters/other UX elements for the number of children, f.e. carousel; or have special styles when empty or have a child in a specific slot, f.e. button with an icon).\nIf that is the case for the component you're building, you need to define slot using ",(0,s.jsx)(n.code,{children:"slot"})," decorator. Thus, your component will become invalidated whenever children are added, removed or swap places in any of its slots."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@slot({ type: HTMLElement, "default": true })\ncontent!: Array<HTMLElement>;\n\n@slot()\nheader!: Array<HTMLElement>;\n\n@slot()\nfooter!: Array<HTMLElement>;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now that this component has slots defined with ",(0,s.jsx)(n.code,{children:"@slot"})," decorator, changes to each of these slots will trigger an invalidation."]}),"\n",(0,s.jsx)(n.p,{children:"And finally, there are components that not only need to render differently based on the number/type of children they have, but they must also get invalidated\nwhenever their children change. This holds true for all components that work with abstract items (such as select with options, combo box with combo box items)\nbecause these abstract items do not have a template (do not render themselves) and therefore rely on their parent to render some DOM for them in its own shadow root. So, when they get invalidated, they must also invalidate their parent."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'@slot({ type: HTMLElement, "default": true, invalidateOnChildChange: true })\ncontent!: Array<HTMLElement>;\n@slot()\nheader!: Array<HTMLElement>;\n@slot()\nfooter!: Array<HTMLElement>;\n'})}),"\n",(0,s.jsxs)(n.p,{children:['Only changes to children in the "content" slot will trigger invalidation for this component. Note that ',(0,s.jsx)(n.code,{children:"invalidateOnChildChange"})," is defined per slot.\nFinally, ",(0,s.jsx)(n.code,{children:"invalidateOnChildChange"})," allows for more fine-granular rules when exactly children can invalidate their parents."]}),"\n",(0,s.jsx)(n.h2,{id:"lifecycle-hooks",children:"Lifecycle hooks"}),"\n",(0,s.jsx)(n.p,{children:"Using the right lifecycle hook for the task is crucial to a well-designed and performant component."}),"\n",(0,s.jsx)(n.h3,{id:"constructor",children:(0,s.jsx)(n.code,{children:"constructor"})}),"\n",(0,s.jsx)(n.p,{children:"Use the constructor for one-time initialization tasks."}),"\n",(0,s.jsx)(n.p,{children:"What to do:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["bind functions to ",(0,s.jsx)(n.code,{children:"this"})," (very common when using the ",(0,s.jsx)(n.code,{children:"ResizeHandler"})," helper class)"]}),"\n",(0,s.jsxs)(n.li,{children:["do one-time work when the first instance of a given component is created (f.e. instantiate a helper class or attach a special event listener to the ",(0,s.jsx)(n.code,{children:"window"})," object)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"What not to do:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["anything rendering-related (use ",(0,s.jsx)(n.code,{children:"onBeforeRendering"}),"/",(0,s.jsx)(n.code,{children:"onAfterRendering"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["anything related to the state (use ",(0,s.jsx)(n.code,{children:"onBeforeRendering"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["anything requiring DOM manipulation (the component isn't attached to the DOM yet - use ",(0,s.jsx)(n.code,{children:"onAfterRendering"})," or ",(0,s.jsx)(n.code,{children:"onEnterDOM"}),"/",(0,s.jsx)(n.code,{children:"onExitDOM"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import UI5Element from "@ui5/webcomponents-base/dist/UI5Element.js";\nimport customElement from "@ui5/webcomponents-base/dist/decorators/customElement.js";\nimport type { ResizeObserverCallback } from "@ui5/webcomponents-base/dist/delegate/ResizeHandler.js";\nimport ItemNavigation from "@ui5/webcomponents-base/dist/delegate/ItemNavigation.js";\n\n\n@customElement({\n    tag: "my-component",\n})\nclass MyComponent extends UI5Element {\n\t_itemNavigation: ItemNavigation;\n\t_handleResizeBound: ResizeObserverCallback;\n\n\tconstructor() {\n\t\tsuper();\n\t\t// bind a method once so that you can pass the same function to register/deregister-based helpers\n\t\tthis._handleResizeBound = this._handleResize.bind(this); \n\n\t\t// do one-time work when the first instance of a component is created\n\t\tif (!isGlobalHandlerAttached) {\n\t\t\tdocument.addEventListener("mouseup", this._deactivate);\n\t\t\tisGlobalHandlerAttached = true;\n\t\t}\n\n\t\t// initialize a helper class for the instance\n\t\tthis._itemNavigation = new ItemNavigation(this, {\n\t\t\tnavigationMode: NavigationMode.Horizontal,\n\t\t\tgetItemsCallback: () => this._getFocusableItems(),\n\t\t});\n\t}\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"onbeforerendering",children:(0,s.jsx)(n.code,{children:"onBeforeRendering"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"onBeforeRendering"})," to prepare variables to be used in the component's template."]}),"\n",(0,s.jsx)(n.p,{children:"What to do:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"prepare calculated (derived) state for use in the renderer"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"What not to do:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["do not try to access the DOM (use ",(0,s.jsx)(n.code,{children:"onAfterRendering"})," instead)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let's take for example a component with the following metadata:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import UI5Element from "@ui5/webcomponents-base/dist/UI5Element.js";\nimport ResizeHandler from "@ui5/webcomponents-base/dist/delegate/ResizeHandler.js";\nimport customElement from "@ui5/webcomponents-base/dist/decorators/customElement.js";\nimport property from "@ui5/webcomponents-base/dist/decorators/property.js";\nimport slot from "@ui5/webcomponents-base/dist/decorators/slot.js";\n\n@customElement({\n    tag: "my-component",\n})\nclass MyComponent extends UI5Element {\n\t@property()\n\tfilter = "";\n\n\t@slot({ type: HTMLElement, individualSlots: true, "default": true })\n\titems!: Array<HTMLElement>\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This component has a ",(0,s.jsx)(n.code,{children:"filter"})," property and a ",(0,s.jsx)(n.code,{children:"default"})," slot that we want to call ",(0,s.jsx)(n.code,{children:"items"})," (thus accessible with ",(0,s.jsx)(n.code,{children:"this.items"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's imagine we want to only show the items whose ",(0,s.jsx)(n.code,{children:"name"})," property matches the value of our ",(0,s.jsx)(n.code,{children:"filter"})," property - so we filter the items by name."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'class MyComponent extends UI5Element {\n\t@property()\n\tfilter = "";\n\n\t@slot({ type: HTMLElement, individualSlots: true, "default": true })\n\titems!: Array<HTMLElement>\n\n\tthis._filteredItems = [];\n\n\tonBeforeRendering() {\n\t\tthis._filteredItems = this.items.filter(item => item.name.includes(this.filter));\n\t}\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.code,{children:"onBeforeRendering"})," we prepare a ",(0,s.jsx)(n.code,{children:"_filteredItems"})," array with some of the component's children (only the ones that have the ",(0,s.jsx)(n.code,{children:"this.filter"})," text as part of their ",(0,s.jsx)(n.code,{children:"name"})," property)"]}),"\n",(0,s.jsx)(n.p,{children:"And finally, in the components's template we have for example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export default function MyComponentTemplate() {\n    return (\n\t\t<div class="my-filter-component">\n\t\t\t{ this._filteredItems.map(item =>\n\t\t\t\t<div class="my-filtered-item">\n\t\t\t\t\t<slot name={item._individualSlot}></slot>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We loop over the ",(0,s.jsx)(n.code,{children:"_fiteredItems"})," array that we prepared in ",(0,s.jsx)(n.code,{children:"onBeforeRendering"})," and for each child we render a ",(0,s.jsx)(n.code,{children:"slot"})," based on the child's ",(0,s.jsx)(n.code,{children:"_individualSlot"})," property,\ncreated automatically by the framework due to the default slot's metadata configuration (",(0,s.jsx)(n.code,{children:"individualSlots: true"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"The usage of this component would be for example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<my-filter-component filter="John">\n\t<my-filter-item name="John Smith"></my-filter-item>\n\t<my-filter-item name="Jane Doe"></my-filter-item>\n\t<my-filter-item name="Jack Johnson"></my-filter-item>\n</my-filter-component>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The user would only see the first and third items as these are the only ones we rendered an individual slot for (the ones matching the ",(0,s.jsx)(n.code,{children:"filter"}),' value of "John").']}),"\n",(0,s.jsxs)(n.p,{children:["In summary: ",(0,s.jsx)(n.code,{children:"onBeforeRendering"})," is the best place to prepare all the variables you are going to need in the component's template."]}),"\n",(0,s.jsx)(n.h3,{id:"onafterrendering",children:(0,s.jsx)(n.code,{children:"onAfterRendering"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"onAfterRendering"})," lifecycle hook allows you to access the DOM every time the component is rendered."]}),"\n",(0,s.jsx)(n.p,{children:"You should avoid using this method whenever possible. It's best to delegate all HTML manipulation to the framework: change the state of the component,\nthe component will be invalidated, the template will be executed with the latest state, and DOM will be updated accordingly.\nIt is an anti-pattern to manually change the DOM."}),"\n",(0,s.jsx)(n.p,{children:"In some cases, however, you must directly access the DOM since certain operations can only be performed imperatively (and not via the template):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"setting the focus;"}),"\n",(0,s.jsx)(n.li,{children:"manually scrolling an element to a certain position;"}),"\n",(0,s.jsx)(n.li,{children:"calling a public method on a DOM Element (for example, to close a popup);"}),"\n",(0,s.jsx)(n.li,{children:"reading the sizes of DOM Elements;"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<div class="my-component">\n\t<input id="first">\n\t<input id="second">\n</div>\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'onAfterRendering() {\n\tthis.shadowRoot.querySelector("#second").focus();\n\tthis._totalWidth = this.shadowRoot.querySelector("div.my-component").offsetWidth;\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"onenterdom-and-onexitdom",children:[(0,s.jsx)(n.code,{children:"onEnterDOM"})," and ",(0,s.jsx)(n.code,{children:"onExitDOM"})]}),"\n",(0,s.jsxs)(n.p,{children:["Unlike ",(0,s.jsx)(n.code,{children:"onBeforeRendering"})," and ",(0,s.jsx)(n.code,{children:"onAfterRendering"}),", which sound like parts of the same flow (but are not, and are actually used for completely independent tasks),\n",(0,s.jsx)(n.code,{children:"onEnterDOM"})," and ",(0,s.jsx)(n.code,{children:"onExitDOM"})," should almost always be used together, therefore they are presented as a whole in this article."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onEnterDOM"})," is executed during the web component's standard ",(0,s.jsx)(n.code,{children:"connectedCallback"})," method's execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onExitDOM"})," is executed during the web component's standard ",(0,s.jsx)(n.code,{children:"disconnectedCallback"})," method's execution"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If you have prior experience with web component development, you could think of ",(0,s.jsx)(n.code,{children:"onEnterDOM"})," as ",(0,s.jsx)(n.code,{children:"connectedCallback"})," and of ",(0,s.jsx)(n.code,{children:"onExitDOM"})," as ",(0,s.jsx)(n.code,{children:"disconnectedCallback"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Note that these hooks are completely independent of the component's rendering lifecycle, and are solely related to its insertion and removal from DOM."}),"\n",(0,s.jsx)(n.p,{children:"Normally, when a web component is created, for example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const b = document.createElement("my-component");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["it is already fully operational, although it isn't in DOM yet. Therefore, you should use ",(0,s.jsx)(n.code,{children:"onEnterDOM"})," and ",(0,s.jsx)(n.code,{children:"onExitDOM"})," only for functionality, related to\nthe component being in the DOM tree at all (and not to rendering, stying or anything related to the shadow root)."]}),"\n",(0,s.jsx)(n.p,{children:"Common use cases are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"registering/de-registering a ResizeHandler"}),"\n",(0,s.jsx)(n.li,{children:"working with Intersection observer"}),"\n",(0,s.jsx)(n.li,{children:"any work you want to carry out only if the component is in the DOM;"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Probably the best example of these hooks is the usage of the ",(0,s.jsx)(n.code,{children:"ResizeHandler"})," helper class."]}),"\n",(0,s.jsxs)(n.p,{children:["The component has a private ",(0,s.jsx)(n.code,{children:"_width"})," property, defined and the following code in its class:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import UI5Element from "@ui5/webcomponents-base/dist/UI5Element.js";\nimport ResizeHandler from "@ui5/webcomponents-base/dist/delegate/ResizeHandler.js";\nimport customElement from "@ui5/webcomponents-base/dist/decorators/customElement.js";\nimport property from "@ui5/webcomponents-base/dist/decorators/property.js";\n\n@customElement({\n    tag: "my-component",\n})\nclass MyComponent extends UI5Element {\n\t@property({ type: Number })\n\t_width = 0;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._fnOnResize = this._onResize.bind(this);\n\t}\n\n\tonEnterDOM() {\n\t\tResizeHandler.register(this, this._fnOnResize);\n\t}\n\n\tonExitDOM() {\n\t\tResizeHandler.deregister(this, this._fnOnResize);\n\t}\n\n\t_onResize() {\n\t\tthis._width = this.offsetWidth;\n\t}\n\n\tget styles() {\n\t\treturn {\n\t\t\tvalueStateMsgPopover: {\n\t\t\t\t"max-width": `${this._width}px`,\n\t\t\t},\n\t\t};\n\t}\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.code,{children:"constructor"})," we bind the ",(0,s.jsx)(n.code,{children:"_onResize"})," method to the component's instance to get a function with the correct context,\nand then in ",(0,s.jsx)(n.code,{children:"onEnterDOM"})," and ",(0,s.jsx)(n.code,{children:"onExitDOM"})," we register/deregister this function with the ",(0,s.jsx)(n.code,{children:"ResizeHandler"})," helper class."]}),"\n",(0,s.jsxs)(n.p,{children:["Then, whenever the component resizes, the ",(0,s.jsx)(n.code,{children:"ResizeHandler"})," will trigger the callback, the metadata ",(0,s.jsx)(n.code,{children:"_width"})," property will be updated to a new value in ",(0,s.jsx)(n.code,{children:"_onResize"}),",\nthe component will be invalidated, and the template will be executed with the new value of ",(0,s.jsx)(n.code,{children:"_width"}),", respectively ",(0,s.jsx)(n.code,{children:"styles"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(14041);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);