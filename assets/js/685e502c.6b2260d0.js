"use strict";(self.webpackChunk_ui5_webcomponents_website=self.webpackChunk_ui5_webcomponents_website||[]).push([[317],{96258:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=n(31085),i=n(71184);const a={title:"Introducing JSX for web component templates",tags:["jsx","template"],slug:"/introducing-jsx",date:"2025-01-07T10:00"},l="Introducing JSX for web component templates",s={permalink:"/webcomponents/blog/introducing-jsx",source:"@site/blog/introducing-jsx.mdx",title:"Introducing JSX for web component templates",description:"We are proud to announce that the 2.6.0 release of the web components adds support for using JSX templates.",date:"2025-01-07T10:00:00.000Z",formattedDate:"January 7, 2025",tags:[{label:"jsx",permalink:"/webcomponents/blog/tags/jsx"},{label:"template",permalink:"/webcomponents/blog/tags/template"}],readingTime:3.68,hasTruncateMarker:!1,authors:[],frontMatter:{title:"Introducing JSX for web component templates",tags:["jsx","template"],slug:"/introducing-jsx",date:"2025-01-07T10:00"},unlisted:!1,prevItem:{title:"The Table Web Component is Now Productive - Here's What's New",permalink:"/webcomponents/blog/productive-table-release"},nextItem:{title:"Announcing UI5 Web Components 2.0! A New Era Begins!",permalink:"/webcomponents/blog/releases/announcing-v2"}},r={authorsImageUrls:[]},c=[{value:"Own HBS compiler",id:"own-hbs-compiler",level:2},{value:"Development experience",id:"development-experience",level:2},{value:"JSX",id:"jsx",level:2},{value:"JSX benefits compared to HBS templates",id:"jsx-benefits-compared-to-hbs-templates",level:2},{value:"Declarative \u2194\ufe0f",id:"declarative-\ufe0f",level:3},{value:"Type checking \u2197\ufe0f",id:"type-checking-\ufe0f",level:3},{value:"Code completion \u2197\ufe0f",id:"code-completion-\ufe0f",level:3},{value:"Code navigation \u2197\ufe0f",id:"code-navigation-\ufe0f",level:3},{value:"Debugging templates \u2197\ufe0f",id:"debugging-templates-\ufe0f",level:3},{value:"No IDE plugin needed \u2197\ufe0f",id:"no-ide-plugin-needed-\ufe0f",level:3},{value:"No new tooling \u2197\ufe0f",id:"no-new-tooling-\ufe0f",level:3},{value:"Smaller template size \u2197\ufe0f",id:"smaller-template-size-\ufe0f",level:3},{value:"Technical aspects",id:"technical-aspects",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["We are proud to announce that the 2.6.0 release of the web components adds support for using ",(0,o.jsx)(t.a,{href:"https://github.com/UI5/webcomponents/pull/10046",children:"JSX templates"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"Until now, Handlebars was the only templating language that could be used. The main goal of the project since the beginning was to have declarative renderers, and Handlebars served this purpose well. There were some drawbacks however."}),"\n",(0,o.jsx)(t.h2,{id:"own-hbs-compiler",children:"Own HBS compiler"}),"\n",(0,o.jsx)(t.p,{children:"Since handlebars originally works with strings only and cannot update the DOM effectively, we had to build our own HBS -> lit-html compiler. This added some technical debt, as not all features from Handlebars were implemented. It also added maintenance effort for a tool we had to update and evolve, when switching to TypeScript for example, or when encountering edge cases not previously considered."}),"\n",(0,o.jsx)(t.h2,{id:"development-experience",children:"Development experience"}),"\n",(0,o.jsx)(t.p,{children:"All templating languages are by default not understood by IDEs out of the box."}),"\n",(0,o.jsx)(t.p,{children:"Code completion is the biggest gap we were seeing - there was simply no way to tell the IDE what to do without writing a plugin, which would be further development effort."}),"\n",(0,o.jsxs)(t.p,{children:["While we added type checking (the compiled HBS code is in a ",(0,o.jsx)(t.code,{children:".ts"})," file so there is some typechecking), it was never complete - type errors are shown in the console, not in the IDE. They were also only top level property type checks - no typechecks inside loops, no typechecks for events and event handlers."]}),"\n",(0,o.jsx)(t.p,{children:"Code navigation was also missing - you could not click on a property in a HBS template to navigate to the property definition in the component itself."}),"\n",(0,o.jsx)(t.h2,{id:"jsx",children:"JSX"}),"\n",(0,o.jsx)(t.p,{children:"JSX is an embeddable HTML-like syntax that gets transformed into JavaScript. It is written inside JavaScript and transformed to JavaScript, which means the TypeScript compiler can do all of the things it does out of the box - not only typechecking, but also provide code completion suggestions and do the code transformation. IDEs also have TypeScript integration, so nothing additional is required."}),"\n",(0,o.jsx)(t.h2,{id:"jsx-benefits-compared-to-hbs-templates",children:"JSX benefits compared to HBS templates"}),"\n",(0,o.jsx)(t.p,{children:"What follows is a quick summary of all improvements offered by JSX."}),"\n",(0,o.jsx)(t.h3,{id:"declarative-\ufe0f",children:"Declarative \u2194\ufe0f"}),"\n",(0,o.jsx)(t.p,{children:"No change here, both are declarative."}),"\n",(0,o.jsx)(t.h3,{id:"type-checking-\ufe0f",children:"Type checking \u2197\ufe0f"}),"\n",(0,o.jsx)(t.p,{children:"Full type checking - not only top-level properties, but also loops, events, event handlers, and code in the template as well."}),"\n",(0,o.jsx)(t.h3,{id:"code-completion-\ufe0f",children:"Code completion \u2197\ufe0f"}),"\n",(0,o.jsx)(t.p,{children:"Full code completion - TypeScript knows exactly what properties are available for each tag, and what their respective values are. Type errors are shown in the IDE and quick fixes also work out of the box."}),"\n",(0,o.jsx)(t.h3,{id:"code-navigation-\ufe0f",children:"Code navigation \u2197\ufe0f"}),"\n",(0,o.jsx)(t.p,{children:"Using Cmd-Click on a property name or an event handler directly jumps to the code location in the component. This was not possible before."}),"\n",(0,o.jsx)(t.h3,{id:"debugging-templates-\ufe0f",children:"Debugging templates \u2197\ufe0f"}),"\n",(0,o.jsx)(t.p,{children:"While it was possible to debug lit-html templates, they were big horizontal lines of template literal code and actually kind of hard to debug. JSX templates look like function calls with whitespaces and show a much better structure that is easier to debug."}),"\n",(0,o.jsx)(t.h3,{id:"no-ide-plugin-needed-\ufe0f",children:"No IDE plugin needed \u2197\ufe0f"}),"\n",(0,o.jsx)(t.p,{children:"All of the benefits above come without the need to write a plugin - IDEs are already integrated with TypeScript that provides all of the above features for free."}),"\n",(0,o.jsx)(t.h3,{id:"no-new-tooling-\ufe0f",children:"No new tooling \u2197\ufe0f"}),"\n",(0,o.jsx)(t.p,{children:"Transforming the template to JavaScript code is handled by the TypeScript compiler. There is absolutely no new code for the transformation step."}),"\n",(0,o.jsx)(t.h3,{id:"smaller-template-size-\ufe0f",children:"Smaller template size \u2197\ufe0f"}),"\n",(0,o.jsxs)(t.p,{children:["Converting all of the ",(0,o.jsx)(t.code,{children:"main"})," and ",(0,o.jsx)(t.code,{children:"fiori"})," components (~140) reduced the gzip size of the bundle by roughly 20 kB."]}),"\n",(0,o.jsx)(t.h2,{id:"technical-aspects",children:"Technical aspects"}),"\n",(0,o.jsxs)(t.p,{children:["The JSX transformation creates a Virtual DOM, and the actual DOM updates are handled by ",(0,o.jsx)(t.a,{href:"https://preactjs.com/",children:"Preact"}),". Preact has a big focus on performance and is very fast and small. Virtual DOM is theoretically slower when updating big lists (as their templates have to be rendered and the diff has to be run), but for the web components, this is not a problem, since the items of the components are coming from the applications and the component only renders a slot where the items will appear."]}),"\n",(0,o.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(t.p,{children:"The switch to JSX improves the web component development experience immensely. Not only is the development experience better, but in the process of migrating the existing components, a lot of bugs were caught that were simply missed in HBS. Size improvements and the good performance make this a real good step for the framework and for component developers."}),"\n",(0,o.jsxs)(t.p,{children:["For more implementation details, you can check the ",(0,o.jsx)(t.a,{href:"https://ui5.github.io/webcomponents/docs/development/templates/",children:"template docs"})," and the ",(0,o.jsx)(t.a,{href:"https://github.com/UI5/webcomponents/pull/10046",children:"PR"})]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},71184:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>s});var o=n(14041);const i={},a=o.createContext(i);function l(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);